/********************************************************************** 
Да се напише функција која како аргумент добива магацин во кој се наоѓаат букви (овој магацин
треба да се модифицира во функцијата). Во функцијата треба да се споредат буквите со буквите
кои се наоѓаат на иста позиција во превртен магацин и доколку две букви во ASCII се
разликуваат за 1 во излезниот магацин да се запише помалата буква. Во функцијата може да се
користат помошни магацини (потребни се минимум два помошни магацини), но користење на
низи не е дозволено. Дополнително во програмата да се дефинира структурата магацин заедно
со сите функции кои се потребни за функционирање на магацинот: за иницијализација, за
проверка дали магацинот е полн и дали е празен, за внесување елементи, за изнесување на
елементи, за гледање на елементот кој е најгоре во магацинот и за печатење на елементите без
вадење на истите од магацинот. Излезниот магацин од функцијата се печати во главната
функција.
Да се напише програма за тестирање на функцијата и магацинот.
Пример:
Пред промената:
Магацинот е:
|q|
|a|
|t|
|s|
|o|
|p|
Прво внесен елемент во магацинот е
p, а последно внесен е q.
После промената:
Магацинот ќе биде:
|p|
|s|
|s|
|p|
Превртениот магацин ќе ги има елементите
|q||a||t||s||o||p|, па разлика од 1 има
помеѓу паровите елементи |p| и |q| (од каде
се добива |p|) и |s| и |t| (од каде се довива
|s|)
**********************************************************************/
#include <iostream>
#include <stdlib.h>
using namespace std;
#define max 10
struct stack{
    int top;
    char niza[max];
    void init (){
        top=-1;
    }
    void underflow(){
        cout<<"underflow";
        return exit(-1);
    }
    void overflow(){
        cout<<"overflow";
        return exit(-1);
    }
    bool isEmpty(){
        return top==-1;
    }
    bool isFull(){
        return top==max-1;
    }
    void push (char e){
        if (isFull()) overflow();
        niza[++top]=e;
    }
    char pop(){
        if (isEmpty()) underflow();
        return niza[top--];
    }
    char peek(){
        if (isEmpty()) underflow();
        return niza[top];
    }
    void print(){
        for (int i=0; i<top; i++){
            cout<<niza[i]<<endl;
        }
    }
};
void pronajdi(stack *m1){
    stack h1, h2;
    h1.init();
    h2.init();
    while (!m1->isEmpty()){
        char c = m1->pop();
        h1.push(c);
        h2.push(c);
    }
    while (!h2.isEmpty()){
        m1->push(h2.pop());
    }
    while (!m1->isEmpty()){
        char c1 = m1->pop();
        char c2 = h1.pop();
        if (c1-c2 == 1){
            h2.push(c2);
        }
        if (c2-c1==1){
            h2.push(c1);
        }
    }
    while (!h2.isEmpty()){
        m1 -> push(h2.pop());
    }
}
int main() {
    stack m1;
    m1.init();
    m1.push('q');
    m1.push('a');
    m1.push('t');
    m1.push('s');
    m1.push('o');
    m1.push('p');
    pronajdi(&m1);
    while (!m1.isEmpty()) {
    cout << m1.pop() << endl;
    }
    return 0;
    }