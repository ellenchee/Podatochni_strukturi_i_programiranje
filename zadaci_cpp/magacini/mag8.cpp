/* Задача 2.1: Соседни броеви во магацин
Да се напише функција која како аргумент добива магацин (овој магацин треба да се
модифицира во функцијата). Во функцијата треба да се проверат сите броеви кои се елементи
на магацинот и секој број да се спореди со неговите соседни броеви. Притоа треба да се утврди
дали соседните броеви може да бидат делители на разгледуваниот број. Ако може, тогаш во
излезниот магацин се запишува количникот (ако и двата соседни броеви може да бидат
делители, тогаш се запишуваат двата количници). Во функцијата може да се користат помошни
магацини (потребен е минимум еден помошен магацин), но користење на низи не е дозволено.
Дополнително во програмата да се дефинира структурата магацин заедно со сите функции кои
се потребни за функционирање на магацинот: за иницијализација, за проверка дали магацинот
е полн и дали е празен, за внесување елементи, за изнесување на елементи, за гледање на
елементот кој е најгоре во магацинот и за печатење на елементите без вадење на истите од
магацинот.
Излезниот магацин од функцијата се испечати во главната функција.
Да се напише програма за тестирање на функцијата и магацинот.
Пример:
Пред промената: 
Магацинот е:
|1|
|2|
|5|
|10|
|2|
Прво внесен елемент во магацинот
е 2, а последно внесен е 1.
После промената:
Магацинот ќе биде:
|2|
|2|
|5|
На елементот 2 соседот 1 може да му биде
делител, па се добива 2 во излезот, на
бројот 10 делител може да му биде 5 (така
се добива вториот елемент 2), а може да му
биде делител и 2 (така се добива елементот 5)*/
#include <iostream>
#include <stdlib.h>
using namespace std;
#define max 10
struct stack{
    int top;
    int a[max];
    void init(){
        top=-1;
    }
    void overflow(){
        cout<<"overflow";
        return exit (-1);
    }
    void underflow(){
        cout<<"underflow"<<endl;
        return exit (-1);
    }
    bool isEmpty(){
        return top==-1;
    }
    bool isFull(){
        return top==(max-1);
    }
    void push(int e){
        if (isFull()) overflow();
        a[++top]=e;
    }
    int pop(){
        if (isEmpty()) underflow();
        return a[top--];
    }
    int peek(){
        if (isEmpty()) underflow();
        return a[top];
    }
};
void promeni(stack& m1){
    stack h1;
    h1.init();
    int count = 0, prev = 0;
    int mom, next;
    while (!m1.isEmpty()){
        mom=m1.pop();
        if (count != 0){
            if (mom%prev==0)
            h1.push(mom/prev);
        }
        if (!m1.isEmpty()){
            next = m1.peek();
            if (mom%next==2){
                h1.push(mom/next);
            }
        }
        prev=mom;
        count++;
    }
    while (!h1.isEmpty()){
        m1.push(h1.pop());
    }
}
int main() {
    stack m1;
    m1.init();
    m1.push(2);
    m1.push(10);
    m1.push(5);
    m1.push(2);
    m1.push(1);
    promeni(m1);
    while (!m1.isEmpty()) {
    cout << m1.pop() << endl;
    }
    return 0;
    }