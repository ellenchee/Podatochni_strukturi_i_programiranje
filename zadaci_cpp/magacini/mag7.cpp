/*Да се напише функција која како аргумент добива магацин (овој магацин треба да се
модифицира во функцијата). Во функцијата треба да се проверат сите броеви кои се елементи
од магацинот и секој број да се спореди со неговите соседни броеви. Притоа треба да се утврди
дали соседните броеви може да бидат делители на разгледуваниот број. Ако може, тогаш во
излезниот магацин се запишува количникот (ако и двата соседни броеви може да бидат
делители, тогаш се запишуваат двата количници). Во функцијата може да се користат
помошни магацини (потребен е минимум еден помошен магацин), но користење на низи не е
дозволено. Дополнително во програмата да се дефинира структурата магацин заедно со сите
функции кои се потребни за функционирање на магацинот: за иницијализација, за проверка
дали магацинот е полн и дали е празен, за внесување елементи, за изнесување на елементи, за
гледање на елементот кој е најгоре во магацинот и за печатење на елементите без вадење на
истите од магацинот. Излезниот магацин од функцијата се печати во главната функција. 
Пример:
Пред промена:
Магацинот е:
|1|
|2|
|5|
|10|
|2|
Прво внесен елемент во
магацинот е 2, а последно внесен
е 1.
После промената:
Магацинот ќе биде:
|2|
|2|
|5|

На елементот 2 соседот 1 може да му биде
делител, па се добива 2 во излезот, на бројот
10 делител може да му биде 5 (така се
добива вториот елемент 2), а може да му
биде делител и 2 (така се добива елементот
5)
Решение:*/
#include <iostream>
#include <string>
using namespace std;
#define MAX 10

struct magacin {
    int niza[MAX];
    int top;
    void init (){
        top=-1;
    }
    void overflow (){
        cout<<"overflow"<<endl;
        exit -1;
    }
    void underflow(){
        cout<<"underflow"<<endl;
        exit -1;
    }
    bool iEmp(){
        return top==-1;
    }
    bool iFul(){
        return top==(MAX-1);
    }
    void push(int e){
        if (iFul()) overflow();
        niza[++top]=e;
    }
    int pop(){
        if (iEmp()) underflow();
        return niza[top--];
    }
    int peek(){
        if (iEmp()) underflow();
        return niza[top];
    }
    void print(){
        for (int i=0; i<=top; i++)
        cout<<niza[i]<<" ";
    }
};
void promeni(magacin &mag)
{
    int count, prev;
    int mom, next;
    magacin pom;
    pom.init();
    while (!mag.iEmp()){
        mom=mag.pop();
        if (count != 0)
            if (mom%prev==0)
                pom.push(mom/prev);
        if (!pom.iEmp()){
            next=mag.peek();
            if (mom%next==0)
                pom.push(mom/next);
        }
        prev=mom;
        count++;
    }
    while(!pom.iEmp()) mag.push(pom.pop());
}
int main()
{
    magacin mag;
    mag.init();
    mag.push(2); //2, 10, 5, 2, 1
    mag.push(10);
    mag.push(5);
    mag.push(2);
    mag.push(1);
    promeni (mag);
    while (!mag.iEmp()){
        cout<<mag.pop()<<endl;
    }
    return 0;
}