/********************************************************
Да се напише функција која како аргумент добива магацин (овој магацин треба да се
модифицира во функцијата). Во функцијата треба да се проверат сите броеви кои се елементи
на магацинот и секој број да се спореди со неговите соседни броеви. Притоа треба да се утврди
дали соседните броеви може да бидат делители на разгледуваниот број. Ако може, тогаш во
излезниот магацин се запишува количникот (ако и двата соседни броеви може да бидат
делители, тогаш се запишуваат двата количници). Во функцијата може да се користат помошни
магацини (потребен е минимум еден помошен магацин), но користење на низи не е дозволено.
Дополнително во програмата да се дефинира структурата магацин заедно со сите функции кои
се потребни за функционирање на магацинот: за иницијализација, за проверка дали магацинот
е полн и дали е празен, за внесување елементи, за изнесување на елементи, за гледање на
елементот кој е најгоре во магацинот и за печатење на елементите без вадење на истите од
магацинот.
Излезниот магацин од функцијата се испечати во главната функција.
Да се напише програма за тестирање на функцијата и магацинот.
Пример:
Пред промената:                     После промената:
Магацинот е:
|1|
|2|
|5|
|10|
|2|
Прво внесен елемент во магацинот
е 2, а последно внесен е 1.
После промената:
Магацинот ќе биде:
|2|
|2|
|5|
На елементот 2 соседот 1 може да му биде
делител, па се добива 2 во излезот, на
бројот 10 делител може да му биде 5 (така
се добива вториот елемент 2), а може да му
биде делител и 2 (така се добива елементот 5)
*********************************************************/
#include <iostream>
#include <stdlib.h>
using namespace std;
#define MAX 10
struct magacin{
    int top;
    int niza[MAX];
    void init (){
        top=-1;
    }
    void overflow(){
        cout<<"overflow"<<endl;
        return exit (-1);
    }
    void underflow(){
        cout<<"underflow"<<endl;
        return exit (-1);
    }
    bool iEmp(){
        return top==-1;
    }
    bool iFul(){
        return top==MAX-1;
    }
    void push(int e){
        if (iFul()) overflow();
        niza[++top]=e;
    }
    int pop(){
        if (iEmp()) underflow();
        return niza[top--];
    }
    int peek(){
        if (iEmp()) underflow();
        return niza[top];
    }
    void print(){
        for (int i=0; i<top; i++){
            cout<<niza[i]<<" ";
        }
    }
};
void promeni(magacin &m){
    int cur=0, prev=0, next=0, count=0;
    magacin m2;
    m2.init();
    while (!m.iEmp()){
        cur=m.pop();
        if (count!=0){
            if(cur%prev==0){
                m2.push(cur/prev);
            }
        }
        if (!m.iEmp()){
            next=m.peek();
            if (cur%next==0){
                m2.push(cur/next);
            }
        }
        prev=cur;
        count++;
    }
    while (!m2.iEmp()){
        m.push(m2.pop());
    }
}
int main() {
    magacin m1;
    m1.init();
    m1.push(2);
    m1.push(10);
    m1.push(5);
    m1.push(2);
    m1.push(1);
    promeni(m1);
    while (!m1.iEmp()) {
    cout << m1.pop() << endl;
    }
    return 0;
    }
